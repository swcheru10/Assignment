(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./binding-registry", "./our-callsite", "./step-binding"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.then = exports.when = exports.given = exports.createMethodDecorator = exports.createStepBinding = void 0;
    const binding_registry_1 = require("./binding-registry");
    const our_callsite_1 = require("./our-callsite");
    const step_binding_1 = require("./step-binding");
    function createStepBinding(flag, stepPattern, callsite, target, propertyKey, tag, timeout) {
        return {
            stepPattern: stepPattern,
            bindingType: flag,
            targetPrototype: target,
            targetPropertyKey: propertyKey,
            argsLength: target[propertyKey].length,
            callsite: callsite,
            tag: tag || binding_registry_1.DEFAULT_TAG,
            timeout: timeout || binding_registry_1.DEFAULT_TIMEOUT
        };
    }
    exports.createStepBinding = createStepBinding;
    function createMethodDecorator(type, stepPattern, tag, timeout) {
        const callsite = our_callsite_1.Callsite.capture();
        return (target, propertyKey, descriptor) => {
            const stepBinding = createStepBinding(type, stepPattern, callsite, target, propertyKey, tag, timeout);
            binding_registry_1.BindingRegistry.instance.registerStepBinding(stepBinding);
            return descriptor;
        };
    }
    exports.createMethodDecorator = createMethodDecorator;
    /**
     * A method decorator that marks the associated function as a 'Given' step.
     *
     * @param stepPattern The regular expression that will be used to match steps.
     * @param tag An optional tag.
     * @param timeout An optional timeout.
     */
    function given(stepPattern, tag, timeout) {
        return createMethodDecorator(step_binding_1.StepBindingFlags.given, stepPattern, tag, timeout);
    }
    exports.given = given;
    /**
     * A method decorator that marks the associated function as a 'When' step.
     *
     * @param stepPattern The regular expression that will be used to match steps.
     * @param tag An optional tag.
     * @param timeout An optional timeout.
     */
    function when(stepPattern, tag, timeout) {
        return createMethodDecorator(step_binding_1.StepBindingFlags.when, stepPattern, tag, timeout);
    }
    exports.when = when;
    /**
     * A method decorator that marks the associated function as a 'Then' step.
     *
     * @param stepPattern The regular expression that will be used to match steps.
     * @param tag An optional tag.
     * @param timeout An optional timeout.
     */
    function then(stepPattern, tag, timeout) {
        return createMethodDecorator(step_binding_1.StepBindingFlags.then, stepPattern, tag, timeout);
    }
    exports.then = then;
});
/**
 * A method decorator that marks the associated function as a 'Before Scenario' step. The function is
 * executed before each scenario.
 *
 * @param tag An optional tag.
 */
// export function before(tag?: string): MethodDecorator {
//   return createMethodDecorator(StepBindingFlags.before, "", tag, undefined)
// }
/**
 * A method decorator that marks the associated function as an 'After Scenario' step. The function is
 * executed after each scenario.
 *
 * @param tag An optional tag.
 */
// export function after(tag?: string): MethodDecorator {
//   return createMethodDecorator(StepBindingFlags.after, "", tag, undefined)
// }
//# sourceMappingURL=definition-decorators.js.map