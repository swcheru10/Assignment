import { StepBinding, StepBindingFlags } from "./step-binding";
export declare function createStepBinding(flag: StepBindingFlags, stepPattern: RegExp | string, callsite: any, target: any, propertyKey: string | symbol, tag?: string, timeout?: number): StepBinding;
export declare function createMethodDecorator(type: StepBindingFlags, stepPattern: RegExp | string, tag: string | undefined, timeout: number | undefined): <T>(target: any, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T>;
/**
 * A method decorator that marks the associated function as a 'Given' step.
 *
 * @param stepPattern The regular expression that will be used to match steps.
 * @param tag An optional tag.
 * @param timeout An optional timeout.
 */
export declare function given(stepPattern: RegExp | string, tag?: string, timeout?: number): MethodDecorator;
/**
 * A method decorator that marks the associated function as a 'When' step.
 *
 * @param stepPattern The regular expression that will be used to match steps.
 * @param tag An optional tag.
 * @param timeout An optional timeout.
 */
export declare function when(stepPattern: RegExp | string, tag?: string, timeout?: number): MethodDecorator;
/**
 * A method decorator that marks the associated function as a 'Then' step.
 *
 * @param stepPattern The regular expression that will be used to match steps.
 * @param tag An optional tag.
 * @param timeout An optional timeout.
 */
export declare function then(stepPattern: RegExp | string, tag?: string, timeout?: number): MethodDecorator;
/**
 * A method decorator that marks the associated function as a 'Before Scenario' step. The function is
 * executed before each scenario.
 *
 * @param tag An optional tag.
 */
/**
 * A method decorator that marks the associated function as an 'After Scenario' step. The function is
 * executed after each scenario.
 *
 * @param tag An optional tag.
 */
//# sourceMappingURL=definition-decorators.d.ts.map